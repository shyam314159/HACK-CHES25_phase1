#!/usr/bin/env python3
"""
OpenTitan Comprehensive Exploitation Framework
Coordinates and executes all discovered vulnerability exploits

Usage: python3 exploit_framework.py [--target TARGET] [--mode MODE]
"""

import os
import sys
import time
import json
import argparse
import subprocess
from pathlib import Path
from typing import Dict, List, Optional
from dataclasses import dataclass
import threading
import queue

@dataclass
class ExploitResult:
    exploit_name: str
    success: bool
    execution_time: float
    output: str
    error: str
    impact_level: str

class OpenTitanExploitFramework:
    def __init__(self, target_device: str = "fpga"):
        self.target_device = target_device
        self.exploit_results = []
        self.exploits_dir = Path(__file__).parent
        self.reports_dir = self.exploits_dir / "reports"
        self.reports_dir.mkdir(exist_ok=True)
        
        # Available exploits and their metadata
        self.exploits = {
            'debug_bypass': {
                'executable': 'debug_access_bypass',
                'description': 'Debug Access Control Bypass',
                'cve': 'CVE-2024-DEBUG-001',
                'cvss': 8.2,
                'impact': 'CRITICAL',
                'prerequisites': ['root_access', 'jtag_connection'],
                'estimated_time': 30
            },
            'alert_timing': {
                'executable': 'alert_handler_timing_attack',
                'description': 'Alert Handler Timing Attack',
                'cve': 'CVE-2024-ALERT-002', 
                'cvss': 7.1,
                'impact': 'HIGH',
                'prerequisites': ['system_access'],
                'estimated_time': 120
            },
            'aes_sidechannel': {
                'executable': 'aes_side_channel_attack',
                'description': 'AES Side-Channel Attack',
                'cve': 'CVE-2024-CRYPTO-003',
                'cvss': 8.1,
                'impact': 'HIGH',
                'prerequisites': ['power_measurement', 'multiple_encryptions'],
                'estimated_time': 300
            },
            'memory_corruption': {
                'executable': 'memory_corruption_exploit',
                'description': 'Memory Corruption Exploit',
                'cve': 'CVE-2024-MEMORY-004',
                'cvss': 6.8,
                'impact': 'MEDIUM',
                'prerequisites': ['system_access'],
                'estimated_time': 60
            }
        }
    
    def check_prerequisites(self, exploit_name: str) -> Dict[str, bool]:
        """Check if prerequisites for an exploit are met"""
        exploit = self.exploits[exploit_name]
        results = {}
        
        for prereq in exploit['prerequisites']:
            if prereq == 'root_access':
                results[prereq] = os.geteuid() == 0
            elif prereq == 'jtag_connection':
                # Check for JTAG device
                results[prereq] = self._check_jtag_connection()
            elif prereq == 'system_access':
                # Basic system access check
                results[prereq] = os.access('/dev/mem', os.R_OK)
            elif prereq == 'power_measurement':
                # Check for power measurement capability
                results[prereq] = self._check_power_measurement()
            elif prereq == 'multiple_encryptions':
                # Check if we can perform multiple encryptions
                results[prereq] = True  # Assume available for demo
            else:
                results[prereq] = False
        
        return results
    
    def _check_jtag_connection(self) -> bool:
        """Check if JTAG device is connected"""
        try:
            # Look for FTDI JTAG devices
            result = subprocess.run(['lsusb'], capture_output=True, text=True)
            return '0403:6010' in result.stdout or '0403:6014' in result.stdout
        except:
            return False
    
    def _check_power_measurement(self) -> bool:
        """Check if power measurement capability is available"""
        # Check for GPIO access or ADC devices
        gpio_paths = ['/sys/class/gpio', '/dev/spidev0.0', '/dev/i2c-1']
        return any(os.path.exists(path) for path in gpio_paths)
    
    def compile_exploit(self, exploit_name: str) -> bool:
        """Compile C exploit if needed"""
        exploit = self.exploits[exploit_name]
        source_file = self.exploits_dir / f"{exploit['executable']}.c"
        binary_file = self.exploits_dir / exploit['executable']
        
        if not source_file.exists():
            print(f"[-] Source file not found: {source_file}")
            return False
        
        # Check if binary exists and is newer than source
        if (binary_file.exists() and 
            binary_file.stat().st_mtime > source_file.stat().st_mtime):
            print(f"[+] Binary {exploit['executable']} is up to date")
            return True
        
        print(f"[+] Compiling {exploit['executable']}...")
        
        # Compilation command with necessary flags
        compile_cmd = [
            'gcc',
            '-o', str(binary_file),
            str(source_file),
            '-lm',  # Math library for correlation calculations
            '-std=c99',
            '-Wall',
            '-Wextra',
            '-O2'
        ]
        
        try:
            result = subprocess.run(compile_cmd, capture_output=True, text=True)
            
            if result.returncode == 0:
                print(f"[+] Successfully compiled {exploit['executable']}")
                return True
            else:
                print(f"[-] Compilation failed for {exploit['executable']}")
                print(f"[-] Error: {result.stderr}")
                return False
                
        except Exception as e:
            print(f"[-] Compilation error: {e}")
            return False
    
    def execute_exploit(self, exploit_name: str, timeout: int = 300) -> ExploitResult:
        """Execute a single exploit with timeout"""
        exploit = self.exploits[exploit_name]
        binary_path = self.exploits_dir / exploit['executable']
        
        print(f"\n[*] Executing {exploit['description']}...")
        print(f"[*] CVE: {exploit['cve']} (CVSS {exploit['cvss']})")
        print(f"[*] Expected impact: {exploit['impact']}")
        
        start_time = time.time()
        
        try:
            # Execute exploit with timeout
            result = subprocess.run(
                [str(binary_path)],
                capture_output=True,
                text=True,
                timeout=timeout
            )
            
            execution_time = time.time() - start_time
            
            # Determine success based on return code and output
            success = result.returncode == 0
            
            exploit_result = ExploitResult(
                exploit_name=exploit_name,
                success=success,
                execution_time=execution_time,
                output=result.stdout,
                error=result.stderr,
                impact_level=exploit['impact']
            )
            
            if success:
                print(f"[+] Exploit completed successfully in {execution_time:.2f}s")
            else:
                print(f"[-] Exploit failed after {execution_time:.2f}s")
                print(f"[-] Error: {result.stderr}")
            
            return exploit_result
            
        except subprocess.TimeoutExpired:
            execution_time = time.time() - start_time
            print(f"[-] Exploit timed out after {timeout}s")
            
            return ExploitResult(
                exploit_name=exploit_name,
                success=False,
                execution_time=execution_time,
                output="",
                error=f"Timeout after {timeout}s",
                impact_level=exploit['impact']
            )
            
        except Exception as e:
            execution_time = time.time() - start_time
            print(f"[-] Exploit execution error: {e}")
            
            return ExploitResult(
                exploit_name=exploit_name,
                success=False,
                execution_time=execution_time,
                output="",
                error=str(e),
                impact_level=exploit['impact']
            )
    
    def run_vulnerability_scan(self) -> Dict:
        """Run vulnerability scanner first"""
        print("[*] Running vulnerability scanner...")
        
        scanner_path = self.exploits_dir / "vulnerability_scanner.py"
        
        try:
            result = subprocess.run([
                'python3', str(scanner_path), 
                str(self.exploits_dir.parent),
                '--json', str(self.reports_dir / 'scan_results.json')
            ], capture_output=True, text=True)
            
            if result.returncode == 0:
                print("[+] Vulnerability scan completed")
                
                # Load scan results
                scan_file = self.reports_dir / 'scan_results.json'
                if scan_file.exists():
                    with open(scan_file) as f:
                        return json.load(f)
            else:
                print(f"[-] Scanner failed: {result.stderr}")
                
        except Exception as e:
            print(f"[-] Scanner error: {e}")
        
        return {}
    
    def run_single_exploit(self, exploit_name: str) -> ExploitResult:
        """Run a single exploit with full preparation"""
        
        if exploit_name not in self.exploits:
            raise ValueError(f"Unknown exploit: {exploit_name}")
        
        exploit = self.exploits[exploit_name]
        
        print(f"\n{'='*60}")
        print(f"EXPLOIT: {exploit['description']}")
        print(f"{'='*60}")
        
        # Check prerequisites
        print("[*] Checking prerequisites...")
        prereq_results = self.check_prerequisites(exploit_name)
        
        missing_prereqs = [k for k, v in prereq_results.items() if not v]
        if missing_prereqs:
            print(f"[-] Missing prerequisites: {', '.join(missing_prereqs)}")
            print(f"[-] Cannot execute {exploit_name}")
            
            return ExploitResult(
                exploit_name=exploit_name,
                success=False,
                execution_time=0,
                output="",
                error=f"Missing prerequisites: {', '.join(missing_prereqs)}",
                impact_level=exploit['impact']
            )
        
        print("[+] All prerequisites satisfied")
        
        # Compile exploit
        if not self.compile_exploit(exploit_name):
            return ExploitResult(
                exploit_name=exploit_name,
                success=False,
                execution_time=0,
                output="",
                error="Compilation failed",
                impact_level=exploit['impact']
            )
        
        # Execute exploit
        return self.execute_exploit(exploit_name, timeout=exploit['estimated_time'] * 2)
    
    def run_all_exploits(self) -> List[ExploitResult]:
        """Run all available exploits in optimal order"""
        
        print("\n" + "="*80)
        print("OPENTITAN COMPREHENSIVE EXPLOITATION FRAMEWORK")
        print("="*80)
        
        # Run vulnerability scan first
        scan_results = self.run_vulnerability_scan()
        
        # Order exploits by severity and dependency
        exploit_order = ['debug_bypass', 'memory_corruption', 'alert_timing', 'aes_sidechannel']
        
        results = []
        
        for exploit_name in exploit_order:
            result = self.run_single_exploit(exploit_name)
            results.append(result)
            self.exploit_results.append(result)
            
            # If critical exploit fails, warn but continue
            if not result.success and result.impact_level == 'CRITICAL':
                print(f"[!] CRITICAL exploit {exploit_name} failed - system may have protections")
        
        return results
    
    def generate_exploitation_report(self, results: List[ExploitResult]) -> str:
        """Generate comprehensive exploitation report"""
        
        report = []
        report.append("="*80)
        report.append("OPENTITAN EXPLOITATION ASSESSMENT REPORT")
        report.append("="*80)
        report.append("")
        
        # Executive summary
        successful_exploits = [r for r in results if r.success]
        failed_exploits = [r for r in results if not r.success]
        
        report.append("EXECUTIVE SUMMARY:")
        report.append(f"Total exploits attempted: {len(results)}")
        report.append(f"Successful exploits: {len(successful_exploits)}")
        report.append(f"Failed exploits: {len(failed_exploits)}")
        report.append("")
        
        if successful_exploits:
            critical_success = [r for r in successful_exploits if r.impact_level == 'CRITICAL']
            high_success = [r for r in successful_exploits if r.impact_level == 'HIGH']
            
            if critical_success:
                report.append("🔴 CRITICAL SECURITY BREACH: System completely compromised")
            elif high_success:
                report.append("🟠 HIGH SECURITY RISK: Significant vulnerabilities exploited")
            else:
                report.append("🟡 MEDIUM SECURITY RISK: Some vulnerabilities exploited")
        else:
            report.append("🟢 SECURITY ASSESSMENT: No exploits successful")
        
        report.append("")
        
        # Detailed results
        report.append("DETAILED EXPLOITATION RESULTS:")
        report.append("")
        
        for result in results:
            exploit_info = self.exploits[result.exploit_name]
            
            report.append(f"Exploit: {exploit_info['description']}")
            report.append(f"CVE: {exploit_info['cve']} (CVSS {exploit_info['cvss']})")
            report.append(f"Status: {'SUCCESS' if result.success else 'FAILED'}")
            report.append(f"Execution time: {result.execution_time:.2f}s")
            report.append(f"Impact level: {result.impact_level}")
            
            if result.success:
                report.append("✅ EXPLOIT SUCCESSFUL")
                # Extract key information from output
                if "Memory dump saved" in result.output:
                    report.append("  - Memory contents extracted")
                if "Key successfully extracted" in result.output:
                    report.append("  - Cryptographic keys compromised")
                if "Alert escalation suppressed" in result.output:
                    report.append("  - Security monitoring bypassed")
                if "Debug access control bypassed" in result.output:
                    report.append("  - Full system control achieved")
            else:
                report.append("❌ EXPLOIT FAILED")
                if result.error:
                    report.append(f"  Error: {result.error}")
            
            report.append("")
        
        # Attack chain analysis
        if successful_exploits:
            report.append("ATTACK CHAIN ANALYSIS:")
            report.append("")
            
            if any(r.exploit_name == 'debug_bypass' and r.success for r in results):
                report.append("1. Initial Access: Debug access control bypassed")
                report.append("   - Attacker gains CPU and memory control")
                report.append("   - All security mechanisms can be disabled")
                report.append("")
            
            if any(r.exploit_name == 'memory_corruption' and r.success for r in results):
                report.append("2. Privilege Escalation: Memory protection bypassed")
                report.append("   - Arbitrary code execution achieved")
                report.append("   - Persistent backdoor installation possible")
                report.append("")
            
            if any(r.exploit_name == 'alert_timing' and r.success for r in results):
                report.append("3. Defense Evasion: Alert system compromised")
                report.append("   - Security monitoring disabled")
                report.append("   - Stealth operation enabled")
                report.append("")
            
            if any(r.exploit_name == 'aes_sidechannel' and r.success for r in results):
                report.append("4. Data Exfiltration: Cryptographic keys extracted")
                report.append("   - All encrypted data compromised")
                report.append("   - Authentication mechanisms bypassed")
                report.append("")
        
        # Risk assessment
        report.append("RISK ASSESSMENT:")
        report.append("")
        
        if len(successful_exploits) >= 3:
            report.append("CRITICAL RISK: Multiple exploits successful")
            report.append("System is completely compromised and cannot be trusted")
        elif len(successful_exploits) >= 2:
            report.append("HIGH RISK: Multiple attack vectors confirmed")
            report.append("Significant security weaknesses require immediate attention")
        elif len(successful_exploits) >= 1:
            report.append("MEDIUM RISK: Some vulnerabilities exploitable")
            report.append("Security improvements needed before production")
        else:
            report.append("LOW RISK: No exploits successful")
            report.append("Security measures appear to be working correctly")
        
        # Recommendations
        report.append("")
        report.append("REMEDIATION RECOMMENDATIONS:")
        
        if any(r.exploit_name == 'debug_bypass' and r.success for r in results):
            report.append("1. CRITICAL: Implement debug access authentication")
            report.append("   - Add proper authorization checks")
            report.append("   - Enable debug access logging")
            report.append("   - Consider hardware-based protection")
        
        if any(r.exploit_name == 'alert_timing' and r.success for r in results):
            report.append("2. HIGH: Fix alert handler timing predictability")
            report.append("   - Implement true random number generation")
            report.append("   - Add unpredictable jitter to timing")
            report.append("   - Validate ping responses properly")
        
        if any(r.exploit_name == 'aes_sidechannel' and r.success for r in results):
            report.append("3. HIGH: Add cryptographic side-channel protection")
            report.append("   - Implement masking countermeasures")
            report.append("   - Add random delays to operations")
            report.append("   - Use protected execution environments")
        
        if any(r.exploit_name == 'memory_corruption' and r.success for r in results):
            report.append("4. MEDIUM: Strengthen memory protection")
            report.append("   - Add bounds checking to controllers")
            report.append("   - Enable stack protection mechanisms")
            report.append("   - Implement memory access controls")
        
        return "\n".join(report)
    
    def save_results(self, results: List[ExploitResult]):
        """Save exploitation results to files"""
        
        # Generate text report
        report = self.generate_exploitation_report(results)
        report_file = self.reports_dir / "exploitation_report.txt"
        
        with open(report_file, 'w') as f:
            f.write(report)
        
        print(f"[+] Exploitation report saved to: {report_file}")
        
        # Save JSON results for tool integration
        json_data = {
            'exploitation_summary': {
                'total_exploits': len(results),
                'successful_exploits': len([r for r in results if r.success]),
                'execution_time': sum(r.execution_time for r in results),
                'target_device': self.target_device
            },
            'results': [
                {
                    'exploit_name': r.exploit_name,
                    'success': r.success,
                    'execution_time': r.execution_time,
                    'impact_level': r.impact_level,
                    'error': r.error if not r.success else None
                }
                for r in results
            ]
        }
        
        json_file = self.reports_dir / "exploitation_results.json"
        with open(json_file, 'w') as f:
            json.dump(json_data, f, indent=2)
        
        print(f"[+] JSON results saved to: {json_file}")

def main():
    parser = argparse.ArgumentParser(description='OpenTitan Exploitation Framework')
    parser.add_argument('--target', '-t', default='fpga',
                       choices=['fpga', 'simulation', 'hardware'],
                       help='Target device type (default: fpga)')
    parser.add_argument('--mode', '-m', default='all',
                       choices=['all', 'debug', 'alert', 'crypto', 'memory'],
                       help='Exploitation mode (default: all)')
    parser.add_argument('--timeout', default=300, type=int,
                       help='Timeout per exploit in seconds (default: 300)')
    
    args = parser.parse_args()
    
    # Initialize framework
    framework = OpenTitanExploitFramework(target_device=args.target)
    
    print(f"[+] OpenTitan Exploitation Framework initialized")
    print(f"[+] Target device: {args.target}")
    print(f"[+] Mode: {args.mode}")
    
    # Execute exploits based on mode
    if args.mode == 'all':
        results = framework.run_all_exploits()
    else:
        # Map mode to exploit name
        mode_map = {
            'debug': 'debug_bypass',
            'alert': 'alert_timing', 
            'crypto': 'aes_sidechannel',
            'memory': 'memory_corruption'
        }
        
        exploit_name = mode_map[args.mode]
        result = framework.run_single_exploit(exploit_name)
        results = [result]
    
    # Save results
    framework.save_results(results)
    
    # Print summary
    successful = len([r for r in results if r.success])
    total = len(results)
    
    print("\n" + "="*60)
    print("EXPLOITATION FRAMEWORK COMPLETED")
    print("="*60)
    print(f"Exploits executed: {total}")
    print(f"Successful exploits: {successful}")
    print(f"Success rate: {successful/total*100:.1f}%")
    
    if successful > 0:
        print(f"\n⚠️  WARNING: {successful} exploits successful!")
        print("System security has been compromised.")
        print("Check exploitation_report.txt for details.")
    else:
        print("\n✅ All exploits failed - security measures appear effective.")

if __name__ == "__main__":
    main()